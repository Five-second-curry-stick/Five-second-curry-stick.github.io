<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>个人网站-杨健豪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="该博客用于记录个人简历，日常所学，包括Cousera、刷题（算法、代码实操）、文献阅读&#x2F;复现">
<meta property="og:type" content="website">
<meta property="og:title" content="个人网站-杨健豪">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="个人网站-杨健豪">
<meta property="og:description" content="该博客用于记录个人简历，日常所学，包括Cousera、刷题（算法、代码实操）、文献阅读&#x2F;复现">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jianhao Yang">
<meta property="article:tag" content="杨健豪 个人网站">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="个人网站-杨健豪" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">个人网站-杨健豪</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数学之美6 - 信息的度量和作用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E6%20-%20%E4%BF%A1%E6%81%AF%E7%9A%84%E5%BA%A6%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8/" class="article-date">
  <time datetime="2019-09-14T06:55:27.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/">数学之美</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E6%20-%20%E4%BF%A1%E6%81%AF%E7%9A%84%E5%BA%A6%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8/">数学之美6 - 信息的度量和作用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! </p>
<hr>
<h1 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h1><h2 id="信息熵的概念"><a href="#信息熵的概念" class="headerlink" title="信息熵的概念"></a>信息熵的概念</h2><blockquote>
<p><img src="https://i.loli.net/2019/09/14/evVoHtLMJkfbzRP.png"></p>
</blockquote>
<h2 id="信息熵公式的理解"><a href="#信息熵公式的理解" class="headerlink" title="信息熵公式的理解"></a>信息熵公式的理解</h2><h3 id="自信息"><a href="#自信息" class="headerlink" title="自信息"></a>自信息</h3><blockquote>
<p>引入一个新的概念：自信息：用来衡量某个具体变量或者事件具体发生时，包含的信息量。在这里我们用I(X)表示</p>
</blockquote>
<blockquote>
<p>如果我们有两个不相关的事件 x 和 y，那么观察两个事件同时发生时获得的信息量应该等于观察到事件各自发生时获得的信息之和，即：I(x,y)=I(x)+I(y)。</p>
</blockquote>
<blockquote>
<p>因为两个事件是独立不相关的，因此 p(x,y)=p(x)p(y)。根据这两个关系，很容易看出 I(x)一定与 p(x)的对数有关 (因为对数的运算法则是 </p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/RkFWV2xcOoDINHf.png"></p>
</blockquote>
<blockquote>
<p>因此，我们有I(x)=−logp(x)其中负号是用来保证信息量是正数或者零。而 log 函数基的选择是任意的（信息论中基常常选择为2，因此信息的单位为比特bits；而机器学习中基常常选择为自然常数）</p>
</blockquote>
<blockquote>
<p>I(x)描述的是随机变量的某个事件发生所带来的信息量。图像如图：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/r7pGxkPsyMv9fC6.png"></p>
</blockquote>
</blockquote>
<h3 id="信息熵的数学表示"><a href="#信息熵的数学表示" class="headerlink" title="信息熵的数学表示"></a>信息熵的数学表示</h3><blockquote>
<p>自信息和信息熵的对比：自信息只能处理单个的输出。而熵是对整个概率分布中不确定性总量进行量化</p>
</blockquote>
<blockquote>
<p>现在假设一个发送者想传送一个随机变量的值给接收者。那么在这个过程中，他们传输的平均信息量可以通过求 I(x)=−logp(x)关于概率分布 p(x)的期望得到，即：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/FzSABWU2hP7tOv3.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>从公式可得，随机变量的取值个数越多，状态数也就越多，信息熵就越大，混乱程度就越大。当随机分布为均匀分布时，熵最大，且 0≤H(X)≤logn</p>
</blockquote>
<h3 id="熵和编码长度"><a href="#熵和编码长度" class="headerlink" title="熵和编码长度"></a>熵和编码长度</h3><blockquote>
<p>信息论中，熵代表着根据信息的概率分布，对信息的编码，所需要的最短平均编码长度。</p>
</blockquote>
<blockquote>
<p>举个简单的例子来理解一下这件事情：假设有个考试作弊团伙，需要连续不断地向外传递4选1单选题的答案。直接传递ABCD的ascii码的话，每个答案需要8个bit的二进制编码，从传输的角度，这显然有些浪费。信息论最初要解决的，就是数据压缩和传输的问题，所以这个作弊团伙希望能用更少bit的编码来传输答案。很简单，答案只有4种可能性，所以二进制编码需要的长度就是取2为底的对数：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/18/f4EsJgQ5OjF61NG.png"></p>
</blockquote>
</blockquote>
<p>此时已经有些像熵的定义了。回顾一下熵的定义，正是求−log(p)的期望值，所以我们把这个思路也套用一下：</p>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/18/lH5EmPaurOCtR38.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/19/CvjkPy6H9oJcRT3.png"></p>
</blockquote>
</blockquote>
<h2 id="信息的作用"><a href="#信息的作用" class="headerlink" title="信息的作用"></a>信息的作用</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/zngEABqN9RCFrSv.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>一个事物内部存在着随机性，也就是不确定性，假定为U，而外部消除这个不确定性唯一的办法就是引入信息I，而需要引入的信息量取决于这个不确定性的大小，即I&gt;U才行。当I&lt;U时间，这些信息可以消除一部分不确定，也就是新的不确定性。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/m86tCrqYKwlfb2F.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>反之，如果没有信息，任何公式或者数字的游戏都无法排除不确定性。</p>
</blockquote>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/18/eNS9bLHoscw6TkZ.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>直接信息和相关信息，都可以降低随机事件的不确定性。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/K4Xoc2fdTBPltbv.png"></p>
</blockquote>
</blockquote>
<h1 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h1><h2 id="条件熵的概念"><a href="#条件熵的概念" class="headerlink" title="条件熵的概念"></a>条件熵的概念</h2><blockquote>
<p>为什么“直接的、相关的”信息也能过消除不确定性？怎么判断信息是相关的还是直接的或者是无关信息？ 为此，需要引入一个概念：条件熵、互信息</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/xDOikEHUaXM7bc4.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>只要证明 H(X)&gt;=H(X|Y) ，也就说明了多了Y的信息后，关于X的不确定性下降了。</p>
</blockquote>
<h2 id="公式的理解"><a href="#公式的理解" class="headerlink" title="公式的理解"></a>公式的理解</h2><blockquote>
<p>条件熵 H(X|Y) 定义为：Y给定的条件下，X对Y的条件概率的信息熵，对Y的数学期望：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/19/e5RMxUpKmjDltEy.jpg"></p>
</blockquote>
</blockquote>
<h1 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h1><h2 id="互信息的引入"><a href="#互信息的引入" class="headerlink" title="互信息的引入"></a>互信息的引入</h2><blockquote>
<p>这里引入另一个概念：“互信息”是作为两个随机事件“相关性”的量化度量。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/qCIP3XKLpyYMsGh.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>当x和y完全相关时，它的取值是1；当二者完全无关时，它的取值是0；</p>
</blockquote>
<h2 id="互信息的具体应用"><a href="#互信息的具体应用" class="headerlink" title="互信息的具体应用"></a>互信息的具体应用</h2><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/WOAUCXbKS8sh9NZ.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/BHgbJl86w9pEFfd.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/1hL9m4zpnUa5fMb.png"></p>
</blockquote>
</blockquote>
<h1 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>相对熵也是用来衡量相关性，但是和随机变量的互信息不同，它是用来衡量两个取值为正数的函数的相关性。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/GZRTefgsyaBVorK.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/mYjd2MyGpv7UN5z.png"></p>
</blockquote>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/17/VcevuKL7QSk2Ryq.png"></p>
</blockquote>
</blockquote>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/19/2trYqlOIMiCcoeV.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/19/NwxuVjOGiTphvCM.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/20/RT2Oy5K9qAIc7sr.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/19/qQyip17jx53eEvs.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/19/XerID2Po9Hlx5hy.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/20/o9xwuGDlXSBKej1.png"></p>
</blockquote>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/20/rT5xXlF8hB6Ia7O.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E6%20-%20%E4%BF%A1%E6%81%AF%E7%9A%84%E5%BA%A6%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8/" data-id="ckgqfij3d002d75456hra3puc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/" rel="tag">数学之美</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数学之美5 - 隐含马尔可夫模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E5%20-%20%E9%9A%90%E5%90%AB%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2019-09-14T02:31:36.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/">数学之美</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E5%20-%20%E9%9A%90%E5%90%AB%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/">数学之美5 - 隐含马尔可夫模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! </p>
<hr>
<h3 id="1-通信模型"><a href="#1-通信模型" class="headerlink" title="1. 通信模型"></a>1. 通信模型</h3><h4 id="1-1-简单的通信模型"><a href="#1-1-简单的通信模型" class="headerlink" title="1.1 简单的通信模型"></a>1.1 简单的通信模型</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/XSukLF73Q2rOZAb.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/kdNxYe6nagRwCDl.png"></p>
</blockquote>
</blockquote>
<h4 id="1-2-通信-与-nlp-的关系"><a href="#1-2-通信-与-nlp-的关系" class="headerlink" title="1.2 通信 与 nlp 的关系"></a>1.2 通信 与 nlp 的关系</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/fLUBztCnhQoNK89.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/3j86vmEPStKHTWI.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>几乎所有的自然语言处理问题都可以等价成通信的解码问题。</p>
</blockquote>
<h4 id="1-3-如何解码"><a href="#1-3-如何解码" class="headerlink" title="1.3 如何解码"></a>1.3 如何解码</h4><blockquote>
<p>在通信中，如何根据接收端的观测信号01,02,03,…来推测信号源发出的信息s1,s2,s3…呢？只需要从所有的源信息中找到最可能产生出观测信号的那一个信息。</p>
</blockquote>
<blockquote>
<p>用概率论的语言来描述就是：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/3CjeaDbHKLqSnP1.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/1uLlPr9nACaFWOk.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/3e5qvTWEbdHJrNA.png"></p>
</blockquote>
</blockquote>
<h3 id="2-隐性马尔可夫模型"><a href="#2-隐性马尔可夫模型" class="headerlink" title="2.隐性马尔可夫模型"></a>2.隐性马尔可夫模型</h3><blockquote>
<p>隐含马尔可夫模型并不是19世纪俄罗斯数学家马尔可夫发明的，而是在20世纪，由美国数学家 鲍姆等人发明的。隐含马尔可夫模型的训练方法（鲍姆-韦尔奇算法）也是以他的名字命名的。</p>
</blockquote>
<blockquote>
<p>要介绍隐含马尔可夫模型，首先还得介绍一下马尔可夫模型。马尔可夫模型的提出，一开始是为了简化统计语言模型的计算。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/HXqcd1AKLtFvi2S.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/RvCsEx8qVW6mKNf.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/S6DyPoHtlafErs7.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/6RLKUwWtsETG9pq.png"></p>
</blockquote>
</blockquote>
<h3 id="3-隐含马尔可夫模型的训练"><a href="#3-隐含马尔可夫模型的训练" class="headerlink" title="3. 隐含马尔可夫模型的训练"></a>3. 隐含马尔可夫模型的训练</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/8n5TipIRABYFm9Q.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E5%20-%20%E9%9A%90%E5%90%AB%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/" data-id="ckgqfij3c002b75452y1q21p2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/" rel="tag">数学之美</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数学之美3 - 统计语言模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E3%20-%20%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2019-09-14T02:24:46.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/">数学之美</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E3%20-%20%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/">数学之美3 - 统计语言模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>!<br>部分借鉴于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/marsggbo/p/8485650.html#autoid-5-0-0">博客</a></p>
<hr>
<h3 id="1-统计语言模型的提出"><a href="#1-统计语言模型的提出" class="headerlink" title="1. 统计语言模型的提出"></a>1. 统计语言模型的提出</h3><h4 id="1-1-20世纪70年代以前"><a href="#1-1-20世纪70年代以前" class="headerlink" title="1.1 20世纪70年代以前"></a>1.1 20世纪70年代以前</h4><blockquote>
<p>统计语言模型产生初衷就是为了解决语言识别问题。</p>
</blockquote>
<pre><code>一个语音识别系统，听到一下句子：The apple and 「pear」 salad is delicious.
系统它应该如何翻译：The apple and 「pear」 salad is delicious.
还是：The apple and 「pair」 salad is delicious.（pear和pair在英文里发音相同）</code></pre>
<blockquote>
<p>科学家们解决以上问题，是通过判断这个文字序列是否合乎语法、含义是否正确。</p>
</blockquote>
<h4 id="1-2-20世纪70年代之后"><a href="#1-2-20世纪70年代之后" class="headerlink" title="1.2 20世纪70年代之后"></a>1.2 20世纪70年代之后</h4><blockquote>
<p>贾里尼克从另外一个角度看待问题，用一个简单的统计模型非常漂亮地搞定了它。</p>
</blockquote>
<blockquote>
<p>他的想法是：一个句子是否合理，就看看他的可能性大小如何，至于可能性就用概率来衡量。比如上面的“苹果梨和沙拉很好吃”的语音问题，第一个句子出现的概率是10的-20次分，第二个句子出现的概率是10的-25次方。那么，第一个句子是最有可能的。</p>
</blockquote>
<h3 id="2-统计语言模型的数学表示"><a href="#2-统计语言模型的数学表示" class="headerlink" title="2. 统计语言模型的数学表示"></a>2. 统计语言模型的数学表示</h3><h4 id="2-1-贾里尼克提出了一个简单的统计模型"><a href="#2-1-贾里尼克提出了一个简单的统计模型" class="headerlink" title="2.1 贾里尼克提出了一个简单的统计模型"></a>2.1 贾里尼克提出了一个简单的统计模型</h4><blockquote>
<p>假定S表示某一个有意义的句子，由一串特定顺序排列的词w1,w2,w3….Wn构成的，这里n是句子的长度。那么P(S)就表示S在文本中出现的可能性。</p>
</blockquote>
<blockquote>
<p>只要把人类自诞生以来说过的话全部统计下，就知道这句话出现的概率了。但是这种方法显然是不可行。因此，需要一个模型来估算P(S)。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/VLHujbP54tODFE7.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>但是这里有一个问题，前面的词P(w1),P(w2)都很容易计算，但到了最后一个词Wn，P(Wn|W1,W2,W3,…,Wn-1)的可能性太多，无法估算</p>
</blockquote>
<h4 id="2-2-马尔可夫假设"><a href="#2-2-马尔可夫假设" class="headerlink" title="2.2 马尔可夫假设"></a>2.2 马尔可夫假设</h4><blockquote>
<p>他给出了一个方法，就是假设任意一个词Wt出现的概率只同他前面的词Wt-1有关，于是问题就变得很简单了。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/JjMcVhzHYkRInrZ.png"></p>
</blockquote>
</blockquote>
<h5 id="2-2-1-计算过程"><a href="#2-2-1-计算过程" class="headerlink" title="2.2.1 计算过程"></a>2.2.1 计算过程</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/HXp1BGhTO2oYCqv.png"></p>
</blockquote>
</blockquote>
<h4 id="2-3-补充：N元模型、高阶模型"><a href="#2-3-补充：N元模型、高阶模型" class="headerlink" title="2.3 补充：N元模型、高阶模型"></a>2.3 补充：N元模型、高阶模型</h4><h5 id="2-3-1-n元模型的概念"><a href="#2-3-1-n元模型的概念" class="headerlink" title="2.3.1 n元模型的概念"></a>2.3.1 n元模型的概念</h5><blockquote>
<p>所谓n元模型，就是假设一个词由前面n-1个词决定。</p>
</blockquote>
<blockquote>
<p>所以在2.2中提到的马尔可夫假设，就是二元模型。</p>
</blockquote>
<h5 id="2-3-2-N一般取值都很小"><a href="#2-3-2-N一般取值都很小" class="headerlink" title="2.3.2 N一般取值都很小"></a>2.3.2 N一般取值都很小</h5><blockquote>
<p>主要有两个原因：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/Ga1IREnbBot9YKq.png"><br><img src="https://i.loli.net/2019/09/11/UzVYJOkCPtRE6ph.png"></p>
</blockquote>
</blockquote>
<h5 id="2-3-3-马尔可夫假设的局限性"><a href="#2-3-3-马尔可夫假设的局限性" class="headerlink" title="2.3.3 马尔可夫假设的局限性"></a>2.3.3 马尔可夫假设的局限性</h5><blockquote>
<p>在自然语言中，上下文之间的相关性可能跨度非常大，甚至一个段落跨越到另一个段落。三元、四元、甚至是更高阶的模型都不能覆盖所有的语言现象。</p>
</blockquote>
<h3 id="3-模型训练"><a href="#3-模型训练" class="headerlink" title="3. 模型训练"></a>3. 模型训练</h3><h4 id="3-1-“不平滑”现象"><a href="#3-1-“不平滑”现象" class="headerlink" title="3.1 “不平滑”现象"></a>3.1 “不平滑”现象</h4><h5 id="3-1-1-原因：零概率和一概率"><a href="#3-1-1-原因：零概率和一概率" class="headerlink" title="3.1.1 原因：零概率和一概率"></a>3.1.1 原因：零概率和一概率</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/Un4A8DEJVeYCsba.png"></p>
</blockquote>
</blockquote>
<h5 id="3-1-2-解决方法1-卡茨退避法"><a href="#3-1-2-解决方法1-卡茨退避法" class="headerlink" title="3.1.2 解决方法1: 卡茨退避法"></a>3.1.2 解决方法1: 卡茨退避法</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/yx6qODkNYzMmEcd.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/kWsSyZMfh431meK.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/K9lHJgNXFu74kAo.png"></p>
</blockquote>
</blockquote>
<h5 id="3-1-3-解决方法2-删除差值"><a href="#3-1-3-解决方法2-删除差值" class="headerlink" title="3.1.3 解决方法2: 删除差值"></a>3.1.3 解决方法2: 删除差值</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/11/wJdhTVanpWgu8Nb.png"></p>
</blockquote>
</blockquote>
<h4 id="3-2-语料选取"><a href="#3-2-语料选取" class="headerlink" title="3.2 语料选取"></a>3.2 语料选取</h4><ul>
<li>训练语料和模型应用的领域，不能相脱节</li>
<li>训练数据通常越多越好</li>
<li>在成本不高的情况下，过滤训练数据是需要的</li>
</ul>
<h3 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4 扩展"></a>4 扩展</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/5q71eE9nLuZANDa.png"> </p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/14/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E3%20-%20%E7%BB%9F%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/" data-id="ckgqfij370025754567dh9is3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/" rel="tag">数学之美</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数学之美4 - 中文分词" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/13/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E4%20-%20%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/" class="article-date">
  <time datetime="2019-09-13T04:59:38.000Z" itemprop="datePublished">2019-09-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/">数学之美</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/13/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E4%20-%20%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/">数学之美4 - 中文分词</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! </p>
<hr>
<h3 id="1-中文分词的演变"><a href="#1-中文分词的演变" class="headerlink" title="1. 中文分词的演变"></a>1. 中文分词的演变</h3><h4 id="1-1-查字典"><a href="#1-1-查字典" class="headerlink" title="1.1 查字典"></a>1.1 查字典</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/8znsjU7V6vXOhPo.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>但是它毕竟太过简单，遇到稍微复杂的问题就无能为力了。</p>
</blockquote>
<h4 id="1-2-最少词数的分词理论"><a href="#1-2-最少词数的分词理论" class="headerlink" title="1.2 最少词数的分词理论"></a>1.2 最少词数的分词理论</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/HP1azbFIxO4Sqnc.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>无法解决二义性问题</p>
</blockquote>
<h4 id="1-3-统计语言模型"><a href="#1-3-统计语言模型" class="headerlink" title="1.3 统计语言模型"></a>1.3 统计语言模型</h4><h5 id="1-3-1-统计语言模型分词方法-的提出"><a href="#1-3-1-统计语言模型分词方法-的提出" class="headerlink" title="1.3.1 统计语言模型分词方法 的提出"></a>1.3.1 统计语言模型分词方法 的提出</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/mLazMkUcGxnN8dB.png"></p>
</blockquote>
</blockquote>
<h5 id="1-3-2-统计语言模型分词方法-的数学概括"><a href="#1-3-2-统计语言模型分词方法-的数学概括" class="headerlink" title="1.3.2 统计语言模型分词方法 的数学概括"></a>1.3.2 统计语言模型分词方法 的数学概括</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/o6zixOpZAqHUYlu.png"></p>
</blockquote>
</blockquote>
<h5 id="1-3-3-实现技巧"><a href="#1-3-3-实现技巧" class="headerlink" title="1.3.3 实现技巧"></a>1.3.3 实现技巧</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/vlf4wiPTguLJBxU.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/24YvBdahRupsjMT.png"></p>
</blockquote>
</blockquote>
<h5 id="1-3-4-动态规划"><a href="#1-3-4-动态规划" class="headerlink" title="1.3.4 动态规划"></a>1.3.4 动态规划</h5><h6 id="1-3-4-1-什么是动态规划"><a href="#1-3-4-1-什么是动态规划" class="headerlink" title="1.3.4.1 什么是动态规划"></a>1.3.4.1 什么是动态规划</h6><blockquote>
<p>动态规划：就是已知问题规模为n的前提A，求解一个未知解B的一种方法。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/lcLXnCvgDV4fMT9.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/sZrJRjYvNuxfQD3.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/BAhNUQs8E5kbRrM.png"></p>
</blockquote>
</blockquote>
<h6 id="1-3-4-2-设计思路"><a href="#1-3-4-2-设计思路" class="headerlink" title="1.3.4.2 设计思路"></a>1.3.4.2 设计思路</h6><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/NXEKPWHFOA8a9cm.png"></p>
</blockquote>
</blockquote>
<pre><code>无后效性：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响</code></pre>
<h6 id="1-3-4-3-算法实例"><a href="#1-3-4-3-算法实例" class="headerlink" title="1.3.4.3 算法实例"></a>1.3.4.3 算法实例</h6><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/j28McTxCUqZwYWe.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/qYJgK7WnUCfhk32.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/cs743dY6vnFGm8T.png"></p>
</blockquote>
</blockquote>
<h6 id="1-3-4-4-维特比算法"><a href="#1-3-4-4-维特比算法" class="headerlink" title="1.3.4.4 维特比算法"></a>1.3.4.4 维特比算法</h6><blockquote>
<p>维特比算法是一种特殊的但应用最广的动态规划算法。利用动态规划可以解决任何一个图中的最短路径问题，而维特比算法则是针对一种特殊的图——篱笆网络的有向图的最短路径问题提出的。之所以重要，是因为凡是使用隐马尔可夫模型描述的问题都可以用它来解码。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/CDwQ7ZSXpjg3VEF.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/dIXxy2cVp6j1lAG.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/Gtv3koN8ZQVuIc6.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/14/wlyUEiGoZVaBtCj.png"></p>
</blockquote>
</blockquote>
<h5 id="1-3-5-统计语言模型分词方法的-局限性"><a href="#1-3-5-统计语言模型分词方法的-局限性" class="headerlink" title="1.3.5 统计语言模型分词方法的 局限性"></a>1.3.5 统计语言模型分词方法的 局限性</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/GAi1pcvtLx4jz3V.png"></p>
</blockquote>
</blockquote>
<h3 id="2-延伸阅读：-工程上的细节问题"><a href="#2-延伸阅读：-工程上的细节问题" class="headerlink" title="2 延伸阅读： 工程上的细节问题"></a>2 延伸阅读： 工程上的细节问题</h3><h4 id="2-1-分词器-准确性的问题"><a href="#2-1-分词器-准确性的问题" class="headerlink" title="2.1 分词器 准确性的问题"></a>2.1 分词器 准确性的问题</h4><blockquote>
<p>如何衡量分词结果的对与错，好与坏看似容易，其实不是那么简单。说他容易，是因为只要对计算机分词的结果和人工分词的结果进行比较就可以了。说他不容易，是因为不同的人对同一个句子可能有不同的分词方法。比如“清华大学”。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/MRG5iOwuvDpWI8o.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/QnJMl29wfbrR8LO.png"></p>
</blockquote>
</blockquote>
<h4 id="2-2-导致人工分词不一致性的原因"><a href="#2-2-导致人工分词不一致性的原因" class="headerlink" title="2.2 导致人工分词不一致性的原因"></a>2.2 导致人工分词不一致性的原因</h4><h5 id="2-2-1-颗粒度的理解"><a href="#2-2-1-颗粒度的理解" class="headerlink" title="2.2.1 颗粒度的理解"></a>2.2.1 颗粒度的理解</h5><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/gAb7vYtpMyxLRPu.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>作者不去强调哪一种颗粒度更好，而是指出：在不同的应用中，会有一种颗粒度比另一种更好的情况。<br>比如在机器翻译中，一般来讲，颗粒度大翻译效果会更好。比如“联想公司”作为一个整体，很容易翻译为：lenovo，如果分词时把他们分开了，就翻译错误了，联想会被翻译为：association。</p>
</blockquote>
<blockquote>
<p>但是在另一些应用中，比如网页搜索，小的颗粒度比大的颗粒度更好。比如“清华大学”这四个字作为一个词，在对网页分词后，它是一个整体了，当用户查询“清华”时，是找不到清华大学的，这就错误了。</p>
</blockquote>
<h5 id="2-2-2-解决方案"><a href="#2-2-2-解决方案" class="headerlink" title="2.2.2 解决方案"></a>2.2.2 解决方案</h5><h6 id="2-2-2-1-原理"><a href="#2-2-2-1-原理" class="headerlink" title="2.2.2.1 原理"></a>2.2.2.1 原理</h6><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/oGBuJgV3pnkaXKc.png"></p>
</blockquote>
</blockquote>
<h6 id="2-2-2-2-实现方法"><a href="#2-2-2-2-实现方法" class="headerlink" title="2.2.2.2 实现方法"></a>2.2.2.2 实现方法</h6><ul>
<li>（1）首先需要一个基本词的词表 和 一个复合词的词表</li>
<li>（2）根据基本词表 和 复合词表，各构建一个语言模型L1 和 L2</li>
<li>（3）根据基本词表和语言模型L1，对句子进行分词，就可以得到小颗粒度的分词结果了。对应下图的分词器，输入的是字串，输出是词串。</li>
<li>（4）在第三步的基础上，再用复合词表和语言模型L2 进行第二次分词。就可以得到大颗粒度的分词结果。对于下图的分词器，输入的是基本词串，输出的是复合词串。<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/24YvBdahRupsjMT.png"></p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/13/v1pQbmVxDtYUKJR.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/13/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E4%20-%20%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/" data-id="ckgqfij38002775453pcxghbb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/" rel="tag">数学之美</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DL9 - 循环序列模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/10/DL9%20-%20%E5%BE%AA%E7%8E%AF%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2019-09-10T00:43:50.000Z" itemprop="datePublished">2019-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/deeplearning/">deeplearning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/10/DL9%20-%20%E5%BE%AA%E7%8E%AF%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/">DL9 - 循环序列模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! This article was writed to take note my study of Machine Learning on <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/nlp-sequence-models/lecture/0h7gT/why-sequence-models">Cousera</a>.<br>部分借鉴于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/marsggbo/p/8485650.html#autoid-5-0-0">博客</a></p>
<hr>
<h3 id="1-数学符号"><a href="#1-数学符号" class="headerlink" title="1 数学符号"></a>1 数学符号</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/PdZVmk5CHTv1MNU.png"></p>
</blockquote>
</blockquote>
<h3 id="2-标准序列模型"><a href="#2-标准序列模型" class="headerlink" title="2 标准序列模型"></a>2 标准序列模型</h3><h4 id="2-1-为什么不用标准神经网络"><a href="#2-1-为什么不用标准神经网络" class="headerlink" title="2.1 为什么不用标准神经网络"></a>2.1 为什么不用标准神经网络</h4><blockquote>
<p>第一点，输入和输出对于不同的例子会有不同的长度 所以,它不是像每一个例子有相同的输入长度 Tx 或有最大的 Yy 值<br />或许每一个句子都有一个最大长度。 也许你可以填充或用零填充每一个输入 到最大长度，<br />但是，这似乎始终不是一个好的表示方法 </p>
</blockquote>
<blockquote>
<p>第二点更严重，那就是 像这样的朴素神经网络结构 它并不会共享那些从不同文本位置学到的特征。 尤其是神经网络学到了经常出现的词汇 如果它出现在了位置1， 就会有标识指出这是人名的一部分 因此，这并不好。 如果它自动计算出经常出现 在其他位置 xt 依然能够表明这可能是一个人名 这也许和你在卷积神经网络课程 中看到的过程很相似 你想要的从图像的一部分学到的模式 来快速生成图像的其他部分， 我们希望在序列数据可以实现相似的效果。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/JpqcTQwvIMSehfW.png"></p>
</blockquote>
</blockquote>
<h4 id="2-2-循环神经网络"><a href="#2-2-循环神经网络" class="headerlink" title="2.2 循环神经网络"></a>2.2 循环神经网络</h4><blockquote>
<p>循环神经网络从左向右扫描数据 每一步，它所用的参数是共享的 所以会有一组参数, 我们将在下一页详细描述。 但是控制从x1到隐藏层的连接 是一组参数，我们用W_ax表示它们 这一组W_ax参数同时 也会被用于每一个步骤 我想我可以在那里写上W_ax 激活函数，各层间水平的链接是由 一组参数W_aa来控制 同样的W_aa也将被用于每一个步骤中 同样，W_ya控制输出预测 我将在下一张幻灯片中详细叙述 这些参数是如何运作的 那么，在循环神经网络中 当预测y3时意味着什么？</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/8ZKOWVMdFP13kY7.png"></p>
</blockquote>
</blockquote>
<pre><code>这种神经网络结构的一个限制 那就是在一确定的时间内预测 
只使用输入或使用输入序列中之前信息 但不使用序列中后面的信息 我们将在稍后的视频中讨论 
双向递归神经网络或 BRNNs 但现在但现在 这种简单的单向神经网络体系结构 
就足以解释这些关键概念了</code></pre>
<h4 id="2-3-前向传递过程"><a href="#2-3-前向传递过程" class="headerlink" title="2.3 前向传递过程"></a>2.3 前向传递过程</h4><blockquote>
<p>Waa 和 Wax是共享的，被用于每一个步骤</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/qsn7OUMtj1hH9I5.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/NMOlHP7D1fA9zwB.png"></p>
</blockquote>
</blockquote>
<h4 id="2-4-反向传递过程"><a href="#2-4-反向传递过程" class="headerlink" title="2.4 反向传递过程"></a>2.4 反向传递过程</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/8cWgAYV17NhGd4B.png"></p>
</blockquote>
</blockquote>
<h3 id="3-不同类型的RNN"><a href="#3-不同类型的RNN" class="headerlink" title="3 不同类型的RNN"></a>3 不同类型的RNN</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/LUDN2STtQxB4kYj.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>(1)输入和输出的数量相同</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/2jxS4EwmAIbYVBK.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>(2)多对1：假設，您想要來解決情緒分級問題 這裡的 x 是一段文字 可能是電影評論說 “這部電影沒啥看頭” (There is nothing to like in this movie) 所以 x 是一個序列 而 y 或許是一個數字從 1 到 5 或者 0 或 1</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/PAQMTmUft2rEeJs.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>(3)1对多：一個一對多神經網路架構的例子是音樂產生器 實際上，您將自己建置一個這種網路 在這個課程程式練習裡，您將會有一個神經網路 輸出一些音符相對於一段音樂 而輸入 x 可能只是一個數字 告訴它您想要什麼類型的音樂， 或者是您想要音樂的第一個音符 如果您不想輸入東西 x 可以是空 (null) 輸入，也可以是零向量 這種神經網路架構裡，您的輸入 x 然後您的 RNN 輸出 第一個值，然後 在沒有任何輸入下做輸出 第二個值，然後繼續下去 第三個值，等等 直到您合成了這段音樂的最後一個音符</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/S8kArhJQ372tBbO.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>(4)编码和解码</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/sIhYvrtu4plQ35y.png"></p>
</blockquote>
</blockquote>
<h3 id="4-语言模型和序列生成"><a href="#4-语言模型和序列生成" class="headerlink" title="4 语言模型和序列生成"></a>4 语言模型和序列生成</h3><h4 id="4-1-什么是语言模型"><a href="#4-1-什么是语言模型" class="headerlink" title="4.1 什么是语言模型"></a>4.1 什么是语言模型</h4><p>案例：</p>
<pre><code>假設我們要建構一個語音辨識系統 當你聽到以下句子: 「蘋果和梨子沙拉很好吃」 
所以你聽到了甚麼 我是說「蘋果和一對沙拉很好吃」還是「蘋果和梨子沙拉很好吃」(注: 
英文中一對(pair)和梨子(pear)同音)

而語音辨識系統挑出第二句的方法 是透過語言模型 來告訴我們這兩句子各自的機率為何 例如, 
一個語言模型可能會說第一句的 機率是3.2乘以10的-13次方 
第二句的機率是5.7乘以10的-10次方 有了這些機率, 第二句是更為可能的 
因為和第一句相比10的指數多3 所以系統會挑出第二句</code></pre>
<blockquote>
<p>語言模型做的事是給定特定句子 它能告訴你特定句子的機率為何 我說的機率是指, 如果你想拿起隨機一份報紙, 隨機打開一個電子郵件或一個網頁或 聽你的朋友說的下一件事 此特定句子, 比如說剛提到的蘋果和梨子沙拉 在這世界中被使用到機率為何 這是以下兩者的基礎要件: 剛提到的語音辨識系統 和機器翻譯系統 我們會期望它輸出最有可能出現的句子</p>
</blockquote>
<blockquote>
<p>因此, 語言模型的基礎工作是輸入一個 我會將其寫成y^&lt;1&gt;, y^&lt;2&gt; 到 y^<Ty>的句子 語言模型做的是將句子表示為 y 而不是 x, 但語言模型做的事是預測 該特定字詞序列的機率</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/I3VTo89q4K6peJA.png"></p>
</blockquote>
</blockquote>
<h3 id="5-如何构建语言模型"><a href="#5-如何构建语言模型" class="headerlink" title="5 如何构建语言模型"></a>5 如何构建语言模型</h3><ul>
<li>首先我们需要一个大型的语料库（Corpus)</li>
<li>将每个单词字符化</li>
<li>2个特殊的单词：EOS（ end of sentence 终止符）、UNknown（字典里没有收录的字词）</li>
</ul>
<blockquote>
<p>之所以将真实值作为输入值很好理解,如果我们一直传错误的值，将永远也无法得到字与字之间的关系。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/5q71eE9nLuZANDa.png"> </p>
</blockquote>
</blockquote>
<h3 id="6-新序列的采样"><a href="#6-新序列的采样" class="headerlink" title="6 新序列的采样"></a>6 新序列的采样</h3><blockquote>
<p><img src="https://i.loli.net/2019/09/10/ZKtSeqm6Q3PDCpA.png"></p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/tC3ySVFANG8uH2Z.png"></p>
</blockquote>
<h3 id="7-如何解决梯度消失的问题"><a href="#7-如何解决梯度消失的问题" class="headerlink" title="7 如何解决梯度消失的问题"></a>7 如何解决梯度消失的问题</h3><h4 id="7-1-梯度爆炸"><a href="#7-1-梯度爆炸" class="headerlink" title="7.1 梯度爆炸"></a>7.1 梯度爆炸</h4><blockquote>
<p>你還記得我們也提到非常深層的神經網路 也有提到梯度爆炸的問題 當進行反向傳播時 梯度不僅可能呈現指數下降 當計算到越深層時, 也可能呈現指數上升 事實上, 當訓練RNN網路時, 儘管梯度消失是較為嚴重的問題 但梯度爆炸也是有可能發生 這可能使神經網路崩潰 因為指數項非常大的梯度可能會造成 參數也隨之變的非常大, 讓神經網路無法被使用 而梯度爆炸很容易被發現 因為你的參數可能會變成 NaN 或者是 顯示為非數字的情況 代表神經網路計算中出現數值溢位問題 如果你真的遇到了梯度爆炸 有可解決方法是運用梯度修剪(gradient clipping) 它代表的是 觀察你的梯度向量 如果它大於某個閾值 重新縮放梯度向量, 確保它不會太大 </p>
</blockquote>
<h4 id="7-2-梯度消失"><a href="#7-2-梯度消失" class="headerlink" title="7.2 梯度消失"></a>7.2 梯度消失</h4><blockquote>
<p>這是一個非常深的網路 假設有100層或更多, 你會從左至右做正向傳播 然後再做反向傳播 我們曾說過, 如果這是很深的網路 那從輸出 y 得到的梯度 會非常難以做反向傳播 並進而難以影響前面幾層的權重 難以影響這裡的計算 </p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/en7kw5ESIAyoBCO.png"></p>
</blockquote>
</blockquote>
<h3 id="8-GRU-gated-recurrent-unit-门控循环单元"><a href="#8-GRU-gated-recurrent-unit-门控循环单元" class="headerlink" title="8. GRU(gated recurrent unit 门控循环单元)"></a>8. GRU(gated recurrent unit 门控循环单元)</h3><h4 id="8-1-门控单元的原理"><a href="#8-1-门控单元的原理" class="headerlink" title="8.1 门控单元的原理"></a>8.1 门控单元的原理</h4><blockquote>
<p> (Gate Recurrent Unit) 一種修改 RNN 隱藏層的方式，使得它更能捕捉 長距離的連結， 對於梯度消失問題有很大幫助 </p>
</blockquote>
<blockquote>
<p>对RNN的一个隐藏层可视化：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/FnmlJG1NDczhQXV.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>您或許需要記住，貓 (cat) 是單數  來確定您理解為什麼使用 “was” 而不使用 “were” 所以 “cat was full” 或者 “cats were full” 當我們從左到右讀這一段句子 GRU 單元將會有一個新的變數稱為 c 代表細胞 (cell)  記憶細胞 而記憶細胞的作用是提供一點點記憶來記住，舉例 貓 (cat) 是單數還是複數 所以當它進入這個句子更後面時 它還可以在工作時考慮到 句子的主題 是否是單數還是複數 所以在時間 t 時，記憶細胞會有一些值 c<t></p>
</blockquote>
<blockquote>
<p>gammaU、C、C候选值，可以是向量，gammaU不一定全是0/1，只是逐元素告訴 GRU 單元 哪一些位置，只是告訴您哪些 記憶細胞的維度需要在每個時間步驟中更新 所以您可以選擇保持一些位置不變 當更新其他位置時 舉個例子，或許您可以選擇一個位置來記住 貓是單數還是複數，或許使用 其他一些位置來記住您談的是有關於食物</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/DyLecoIdkmaMRE3.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/12/hqxm7n45iPDM9Gp.png"></p>
</blockquote>
</blockquote>
<h4 id="8-2-门控单元的优点"><a href="#8-2-门控单元的优点" class="headerlink" title="8.2 门控单元的优点"></a>8.2 门控单元的优点</h4><blockquote>
<p>因為 gamma 可以相當接近 0 可能是 0.000001 甚至更小 它不太會有梯度消失的問題 因為您說 gamma 相當接近 0 這個基本上會讓 c<t><t> 等於 c<t-1><t> 而 c<t><t> 的值會相當程度的保留 即使經過了很多很多時間步驟 所以這個可以明顯地幫助解決梯度消失問題 而讓神經網路可以使用甚至更長的距離的依賴性 </p>
</blockquote>
<h4 id="8-3-完整版GRU"><a href="#8-3-完整版GRU" class="headerlink" title="8.3 完整版GRU"></a>8.3 完整版GRU</h4><blockquote>
<p><img src="https://i.loli.net/2019/09/10/MYLpqUmN4gO9Hka.png"></p>
</blockquote>
<h3 id="9-LSTM-长短期记忆单元"><a href="#9-LSTM-长短期记忆单元" class="headerlink" title="9. LSTM 长短期记忆单元"></a>9. LSTM 长短期记忆单元</h3><blockquote>
<p>LSTM 的一個新特性是 並非只用一個更新門閘來控制記憶過程 如這裡的兩個項 我們是用兩個不同來源的項 我們不再只用 Γᵤ 和 (1-Γᵤ) 而是在這裡用 Γᵤ 然後用遺忘門閘 Γf 那這個 Γf 門閘 用到了 sigmoid S型函數<br />其它和你之前看到的差不多 這裡是 x<t> 並加上 bf 然後我們會有一個新的輸出門閘 一樣是sigmoid S型函數, 用到 Wₒ 最後加上 bₒ 然後, 記憶細胞的更新值 c<t> 等於 Γᵤ 這個 ＊ 表示矩陣中逐元素的乘積 這是個向量間逐元素乘積 再加上, 取代 (1-Γᵤ) 用的是另一項遺忘門閘 Γf 乘以 c<t-1> 這樣給了記憶細胞選擇權 去決定使用多少舊數值 c<t-1> 並直接加上新的值 c~<t> 所以這裡是使用兩個分開的項, 更新門閘和遺忘門閘 這些代表更新門閘, 遺忘門閘, 還有輸出門閘 最後, 取代 GRU 中的 a<t>=c<t> a<t> 等於輸出門閘和 c<t> 去做逐元素乘積 那這就是 LSTM 的主要方程式 它用了三個門閘, 而並非兩個 並把三個門閘用到了不同的地方</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/LBMgshFSu4bDa3z.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/MYTc3tpVQgJZB4d.png"></p>
</blockquote>
</blockquote>
<h3 id="10-双向RNN模型"><a href="#10-双向RNN模型" class="headerlink" title="10. 双向RNN模型"></a>10. 双向RNN模型</h3><blockquote>
<p>「雙向 RNN 模型」 它讓你在序列的某個時間點上 可以同時獲得過去或未來的資訊</p>
</blockquote>
<blockquote>
<blockquote>
<p>這就是雙向 RNN 的運作 而這些 RNN 單元不僅可是標準的 RNN 單元 也可以是 GRU 或是 LSTM 單元 事實上, 大多是自然語言處理問題 特別是有大量文本的問題 有 LSTM 單元的雙向 RNN 是很常被使用的 所以, 如果你遇到了 NLP 問題, 而且句子都是完整的 並想嘗試標記這些句子 一個有 LSTM 單元的雙向 RNN 有前向和反向的計算, 應該會是你的首選 </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/xl6JrEHzTC2Su1V.png"></p>
</blockquote>
</blockquote>
<h3 id="11-深度RNN"><a href="#11-深度RNN" class="headerlink" title="11. 深度RNN"></a>11. 深度RNN</h3><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/q7GvwWseayzp3PH.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p> <strong><em>在上图所示框架基础上</em></strong></p>
</blockquote>
<blockquote>
<p> ，可以改进的地方（1）： 在RNN之后，然後用一些深度層但不用水平連結 使用深度網路來最後預估 y&lt;1&gt; 您可以用相同的深度網路來預估 y&lt;2&gt; 所以這種網路架構比較常見 您有三個遞迴單元以時間相連 連結一個網路 之後連結一個網路 就像 y&lt;3&gt; 跟 y&lt;4&gt; 一樣 這裡有深度網路，但這些並沒有水平連結 所以這是一種比較常見的架構</p>
</blockquote>
<blockquote>
<p>改进（2）：這些區塊不只一定是標準的 RNN 簡單的 RNN 模型 它們也可以是 GRU 區塊，或是 LSTM 區塊 </p>
</blockquote>
<blockquote>
<p>改进（3）：您也可以在雙向 RNN 上建立深度版本 </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/10/DL9%20-%20%E5%BE%AA%E7%8E%AF%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/" data-id="ckgqfij2n000t754594lrf4jq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deeplearning/" rel="tag">deeplearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DL8 - 迁移、多任务、端到端" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/DL8%20-%20%E8%BF%81%E7%A7%BB%E3%80%81%E5%A4%9A%E4%BB%BB%E5%8A%A1%E3%80%81%E7%AB%AF%E5%88%B0%E7%AB%AF/" class="article-date">
  <time datetime="2019-09-09T14:06:17.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/deeplearning/">deeplearning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/DL8%20-%20%E8%BF%81%E7%A7%BB%E3%80%81%E5%A4%9A%E4%BB%BB%E5%8A%A1%E3%80%81%E7%AB%AF%E5%88%B0%E7%AB%AF/">DL8 - 迁移学习、多任务学习、端到端深度学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! This article was writed to take note my study of Machine Learning on <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning-projects/lecture/WNPap/transfer-learning">Cousera</a>.</p>
<hr>
<h3 id="1-迁移学习"><a href="#1-迁移学习" class="headerlink" title="1. 迁移学习"></a>1. 迁移学习</h3><h4 id="1-1-什么是迁移学习"><a href="#1-1-什么是迁移学习" class="headerlink" title="1.1 什么是迁移学习"></a>1.1 什么是迁移学习</h4><blockquote>
<p>是有时你可以把在一个任务中神经网络 学习到的东西，应用到另一个任务中去。 比如，你可以让神经网络 学习去识别物体，比如猫，然后用学习到的 （一部分）知识 来帮助你更好地识别X射线的结果。 这就是所谓的迁移学习。</p>
</blockquote>
<blockquote>
<p>例如放射扫描结果的诊断过程 即真实地读取X光扫描图像 你可以做的就是，取出这个神经网络的最后一层 并移除掉这一层以及其相关的权重 然后为最后一层神经网络创建一个新的随机初始化的权重 使用新建的这个输出层来进行放射结果的诊断 所以，具体来说，在训练模型的第一阶段， 当你在做图像识别的任务时， 你训练了所有常用的神经网络的参数，所有权值 所有层，然后这个模型 现在能够做出图像识别的预测。 训练得出了这样一个神经网络之后， 要实现迁移学习，你现在需要把数据集X和Y 设定为放射影像。 现在的Y是你想要预测的诊断结果， 你要做的是初始化最后一层的权值 我们叫这个为WL 和PL。 然后现在，重新在新的数据集上训练这个神经网络， 就是新的放射数据集上。</p>
</blockquote>
<blockquote>
<p>你有几种方法来重新训练这个放射数据的神经网络。 如果你只有一个小的放射数据集， 你可以只重新训练最后一层的权值，就是WL 和PL，同时保留其它所有参数。 如果你有足够的数据， 你也可以重新训练神经网络的其余所有层。 我们的经验就是如果你有一个小规模的数据集， 那么就去重新训练最后一层和输出层的神经网络， 或者你也可以训练最后一到两层的神经网络。 但是如果你有大量的数据， 你或许可以对这个神经网络的所有参数都进行重新训练。 要是你对神经网络的所有参数进行重新训练， 那么这样训练的初始化阶段 有时候被我们叫做预训练（pre-training） 原因是，你在是使用图像识别的数据 来预初始化（pre-initialize）或者说预训练神经网络的权重。 然后如果你在之后对所有的权重进行更新， 那么在放射扫描的数据上的训练有时候被我们叫做微调（fine tuning) 所以有时候你会在深度学习领域听到预训练（pre-training）和微调（fine tuning）这些词， 上面我所说的就是他们在迁移学习中 表达的真正含义。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/Iuohf9DQGxSL4PO.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>一个迁移学习不适用的例子是， （上面讲到的）数据规模被颠倒过来的时候。</p>
</blockquote>
<h4 id="1-2-迁移学习什么时候适用"><a href="#1-2-迁移学习什么时候适用" class="headerlink" title="1.2 迁移学习什么时候适用"></a>1.2 迁移学习什么时候适用</h4><ul>
<li><p>如果你尝试 从某个任务A中学习到的信息迁移到某个任务B中， 那么当任务A和任务B在有相同的输入时，迁移学习才能适用。</p>
</li>
<li><p>必须在任务A比任务B有更多的数据时，迁移学习才适用。 所有条件都是在想要把任务B做好的前提下 因为在任务B中的数据比在任务A中更加地有价值， 通常你需要为任务A准备更多的数据，因为 在任务A中的样本比任务B中的样本价值更低。</p>
</li>
<li><p>迁移学习更加适用的场景 是当你认为，任务A中的低层次特征会帮助任务B达成目标。</p>
</li>
</ul>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/pGYs6W9uzi2O5XC.png"></p>
</blockquote>
</blockquote>
<h3 id="2-多任务学习"><a href="#2-多任务学习" class="headerlink" title="2. 多任务学习"></a>2. 多任务学习</h3><h4 id="2-1-什么是多任务学习"><a href="#2-1-什么是多任务学习" class="headerlink" title="2.1 什么是多任务学习"></a>2.1 什么是多任务学习</h4><pre><code>在多任务学习中,你（多个任务）一起开始 尝试让一个神经网络同时做几件事 
然后,每个任务将会帮助完成其他任务。 我们来看个例子让我们来看一个例子</code></pre>
<blockquote>
<p> 你可以有一个神经网络以x作为输入和 输出为四维的y。 请注意这里的输出,我已经绘制了四节点。 第一个节点,我们试图检测是否有行人 在这张图片中 第二个输出会检测到是否有辆车 还会检测到是否有个停车标志和红绿灯</p>
</blockquote>
<blockquote>
<p>所以这里的y^是四维的。为了训练这个神经网络,你需要定义 这个神经网络的损失函数 预测输出的y^(i)是4x1维的。 损失是整个训练集的平均损失 为1除以m，乘以从i=1到m的总和 j从1到4各自预测的损失</p>
</blockquote>
<blockquote>
<p>它只是将4个部分行人、车、停车标志 红绿灯进行相加 这里的L是普通的逻辑斯蒂损失函数。</p>
</blockquote>
<blockquote>
<p>把这写下来 所以就是 yj(i)logŷj(i)+(1-yj(i))log(1-ŷj(i))</p>
</blockquote>
<blockquote>
<p>和softmax回归区别是,不像softmax 回归,它将单个标签分配给单个示例。 这一个图像可以有多个标签。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/EoCB1hFp3YaOxVA.png"></p>
</blockquote>
</blockquote>
<h4 id="2-2-什么时候适用多任务学习"><a href="#2-2-什么时候适用多任务学习" class="headerlink" title="2.2 什么时候适用多任务学习"></a>2.2 什么时候适用多任务学习</h4><blockquote>
<p>1 你要训练一系列的任务可以 共享一些低层次的特征 自动驾驶的例子中,在识别交通灯 汽车和行人时,都有相似的特征 这可以帮你识别停车标志，因为他们都是道路特征</p>
</blockquote>
<blockquote>
<p>2 其次——这不是硬性的规则,所以不总是存在的—— 但我看到很多成功的多任务学习，他们 每个单项任务的数据量非常相似。</p>
</blockquote>
<blockquote>
<p> 如果神经网络不够大，多任务学习 与单项训练相比会损害准确率。 但如果你训练足够大的神经网络,那多任务学习 应该不会或很少影响性能。 与你分别单独训练不同任务相比， 它实际上能够提高性能。 这就是多任务学习。 实际上多任务学习要比迁移学习用得少得多。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/AvbUWpqhQwZiCjV.png"></p>
</blockquote>
</blockquote>
<h3 id="3-“端到端”的机器学习"><a href="#3-“端到端”的机器学习" class="headerlink" title="3. “端到端”的机器学习"></a>3. “端到端”的机器学习</h3><blockquote>
<p>什么是“端到端“的深度学习呢？ 简单地说，我们有一些数据处理系统 或者是由多个阶段组成的学习系统 端到端的深度学习做的 就是它可以捕获所有的阶段 并且，通常可以将其替代为单个神经网络 也就是说运行速度更快 </p>
</blockquote>
<blockquote>
<p>所以，如果端到端深度学习可行， 可以非常有效和简化系统，且 不用建立很多手工设计的单个组件。 但是它不是万能的， 它并不总是有效。</p>
</blockquote>
<h4 id="3-2-端到端的优缺点"><a href="#3-2-端到端的优缺点" class="headerlink" title="3.2 端到端的优缺点"></a>3.2 端到端的优缺点</h4><blockquote>
<p>优点1: 端到端学习真正地让数据发挥主导作用 所以如果你有足够的(X, Y)的数据 那么不论那个能最好地将X映射到Y的函数是什么样子 只要你有足够大的神经网络 顺利的话，神经网络都能拟合出来 通过单纯的使用机器学习方法 你的神经网络能够更好从输入的X-&gt;Y中 学习到数据内在的统计学特性 而不是被迫去反映人的先见 </p>
<p>优点2：所需的人类动手设计的组件变的更少了 所以这可以简化你的设计工作流程 意味着你不需要话大量的时间去动手设计特征 手工设计这些中间表示形式</p>
</blockquote>
<blockquote>
<p>缺点1：第一，端到端学习需要大量的数据 所以为了使用机器学习直接得出X到Y的映射 你或许需要大量的(X，Y)数据 </p>
</blockquote>
<blockquote>
<p>缺点2: 它排除了一些具有潜在用途的手工设计组件 所以机器学习研究人员往往会轻视手工设计的组件 但是如果你没有足够的数据 那么你的学习算法就不能够洞悉你数据中的规律 如果你的训练集很小 所以手工设计的组件的确是一条可行之路 去将人工知识融入到算法中 而且这并不总是个坏主意 我认为学习算法有两个主要的知识来源 一个是数据，另一个是你手工设计的东西 这些东西可以是算法中的组件，或者是特征，或者是其他的东西 所以如果你有很多很多的数据 手工设计就没那么重要了，但是如果你没有那么多的数据 那么有一个精心手工设计的系统实际上可以让人们向 算法中注入人类关于这个问题的知识</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/10/qfM29lj1mAUpPaQ.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/09/DL8%20-%20%E8%BF%81%E7%A7%BB%E3%80%81%E5%A4%9A%E4%BB%BB%E5%8A%A1%E3%80%81%E7%AB%AF%E5%88%B0%E7%AB%AF/" data-id="ckgqfij2m000q7545blgjak98" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deeplearning/" rel="tag">deeplearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DL7 - 构造机器学习项目（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/09/DL7%20-%20%E6%9E%84%E9%80%A0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%882%EF%BC%89/" class="article-date">
  <time datetime="2019-09-09T09:44:28.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/deeplearning/">deeplearning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/09/DL7%20-%20%E6%9E%84%E9%80%A0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%882%EF%BC%89/">DL7 - 构造机器学习项目（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! This article was writed to take note my study of Machine Learning on <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning-projects/lecture/WNPap/transfer-learning">Cousera</a>.</p>
<hr>
<h3 id="1-错误分析"><a href="#1-错误分析" class="headerlink" title="1. 错误分析"></a>1. 错误分析</h3><blockquote>
<p>什么叫表现上限：</p>
</blockquote>
<pre><code>拿大约100张分类错误的验证集图片&lt;br /&gt;并进行手动检测 只需要数一数 看有多少张 
验证集中标错的样本实际上是狗的图片 现在 假设事实证明 在验证集中分错的100张样本里&lt;br /&gt;
有5%是狗的图片 也就是说 验证集中&lt;br /&gt;分错的100张中有5张是狗 这意味着在这100张图片中 
特指你分错的这100张 即使完全解决狗的问题&lt;br /&gt;也只在这100张中多分对了5张 换言之 
若只有5%的错误是狗照片 如果你在狗的问题上花了大量时间 最好的情况也就是 你的错误率 
从10%下降到9.5% 对吗 这5%是错误里的相对下降值&lt;br /&gt;因此是从10%下降到9.5% 
那么你可能可以合理地判断出</code></pre>
<blockquote>
<p>错误分析：</p>
</blockquote>
<blockquote>
<p> 假设有别的事情发生了 假设 在验证集里错标的100张样本中 你发现他们中的50张实际上是狗的图像 所以50%是狗的照片 现在你可以更确定地把时间花在狗的问题上 在这种情况下 如果你真的解决了狗的问题 你的错误率可能将从这10%下降到5% 你可能会认为错误率减半是值得付出努力的 专注于减少被错误标识的狗 我知道在机器学习中 有时我们会贬低 手动操作或使用太多人工判断 但是如果你在构建应用系统<br />那么这个简单的计数过程 也就是错误分析 可以节省你很多时间 在决定什么是最重要的 或哪个方向最有希望 值得关注</p>
</blockquote>
<h3 id="2-如何对待错误数据"><a href="#2-如何对待错误数据" class="headerlink" title="2. 如何对待错误数据"></a>2. 如何对待错误数据</h3><blockquote>
<p>1 当错误数据发生在 <strong><em>训练集</em></strong></p>
<p>事实证明，深度学习算法 对训练集中的随机错误很稳健 只要你的错误，或者说错误标记的例子 只要这些错误不是那么偏离随机分布 而可能只是由标记的人偶然的疏忽造成的， 比如随机按下了错误的键 总之，如果这些错误是相当随机的 那么我们基本可以不管（这些错误） 不用花费太多的时间去纠正它们 当然了，仔细检查你的训练集和标签 并且纠正它们，肯定是无害的 有时候，这是很值得花费时间去做的， 但你也可以不做，只要总数据量够大， 而且实际错误标记的数据占比不高 </p>
</blockquote>
<blockquote>
<p>2 这些错误标记的数据（对开发集和测试集）的影</p>
</blockquote>
<blockquote>
<p>一个比较推荐的做法是，在错误分析的过程中 增加一列，去统计 Y的标签错误的数量</p>
<p> 如果这些错误对你评估算法在开发集上的效果 有很大的影响的话 那就继续做吧，花时间去纠正这些错误标签 但是如果没有太大影响 对你用开发集去评估模型 那你的时间最好不要花在这上面 </p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/adxyPUD6WX9cv1m.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>3 如果你决定探究开发集 手动重新检查标签，并且尝试纠正一些标签 这里由一些额外的指南或者说原则去考虑</p>
</blockquote>
<blockquote>
<p>(1) 如果你要探究并纠正开发集中的一些问题 我会建议将这个过程也应用到测试集，以确保 它们依然服从同样的分布</p>
<p>（2）我强烈建议你考虑检查 你的算法准确预测和错误预测的例子（这个原则不常被使用，因为判断正确的数据太多）</p>
</blockquote>
<blockquote>
<p>(3) 训练集 和 开发/测试集，可能来自不同的分布</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/fERMJN9LkO3VoHc.png"></p>
</blockquote>
</blockquote>
<h3 id="3-如何快速构建一个新的系统"><a href="#3-如何快速构建一个新的系统" class="headerlink" title="3. 如何快速构建一个新的系统"></a>3. 如何快速构建一个新的系统</h3><blockquote>
<p>我的建议是<br />快速构建你的第一个系统 然后迭代 这个建议不那么适用<br />如果你处于一个 你经验丰富的领域 这个建议同样也不适用于 当有很多可以参考的学术论文 针对你正在研究的<br />几乎完全相同的问题 比如说 有很多学术文献研究人脸识别 如果你正在尝试建立人脸识别系统 你可以从一开始就打造一个复杂的系统 依托于大量的学术文献 但是 如果第一次<br />你正在研究一个新的问题 那么我建议你 真的不要考虑太多<br />也不要把你的第一个系统做得太复杂 只要建立一个快速的早期的系统<br />然后使用它 来帮助你确定一个优先级<br />如何来改善你的系统</p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/tj5F8rplvEuaCMQ.png"></p>
</blockquote>
<h3 id="4-当training-和-test数据来自不同分布"><a href="#4-当training-和-test数据来自不同分布" class="headerlink" title="4. 当training 和 test数据来自不同分布"></a>4. 当training 和 test数据来自不同分布</h3><blockquote>
<p>方案一，将两个集合的数据混合在一起，再重新分配(建议不要采用方案一 因为它设置的开发集使你的团队致力于 优化一个与你实际关心的目标<br />并不相同的数据分布)</p>
</blockquote>
<blockquote>
<p>这样的数据分配有其优点和缺点 优点是这样一来你的训练/开发/测试集 都来自于同一分布 易于管理 而缺点 一个巨大的缺点是 仔细看看你的开发集<br />它有2,500个样例 但是大部分来自网页图片的分布 而不是你真正关心的<br />来自移动应用图片的分布</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/gklE3SrKectjwy2.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>方案二：假设训练集仍然包含205,000个图片，练集包含200,000个网络图片 和5,000个移动应用图片 开发集包含2,500个移动应用图片 测试集也包含2,500个移动应用图片 按照这种方式划分训练/开发/测试集 其优点是你瞄准的是正确的目标 你在向你的团队表明<br />我的开发集数据来自于移动应用 而这正是你真正关心的图片的分布 让我们来建立一个机器学习系统 它在移动应用图片分布的表现的确很好 当然其缺点就是你的训练集的分布 不同于您的开发和测试集分布 但事实证明这样划分训练/开发/测试集 长期来说性能更好 </p>
</blockquote>
<h3 id="5-不匹配数据分布的偏差和方差"><a href="#5-不匹配数据分布的偏差和方差" class="headerlink" title="5. 不匹配数据分布的偏差和方差"></a>5. 不匹配数据分布的偏差和方差</h3><blockquote>
<p>通过估计学习算法的偏差和方差 能帮你确定下一步工作的优先级 但当你的训练集 开发集 测试集 来自不同的分布时 偏差和方差的分析方法也会相应变化</p>
</blockquote>
<blockquote>
<p>这时误差分析要注意 当你从训练集误差 转移到开发集误差时 有两件事情变了 一 算法看到的数据只有训练集没有开发集 二 开发集和训练集数据分布不同 因为同时存在两个变量 我们很难判断 这9%的误差 有多少是因为 算法未接触开发集 而影响了方差 又有多少是 因为开发集的数据分布不同</p>
</blockquote>
<blockquote>
<p>为了辨识出这两个影响 如果你对这两种影响完全不了解 别担心 别担心 我们马上就会说到 为了梳理出这两个影响 我们需要新定义一组数据 叫做训练-开发集(training-dev set) 这是一个新的数据子集 我们要让它与训练集拥有同样的数据分布 但你不用直接拿它来训练你的网络 就是这样子 </p>
</blockquote>
<blockquote>
<p>之前我们已经建立了训练集 训练集和测试集 如图所示 开发集和测试集属于同分布 训练集数据属于不同分布 我们要做的是将训练集随机混淆(shuffle) 取出一小块数据作为训练-开发集 如同开发集与测试集分布相同 训练集与训练-开发集也遵循相同分布</p>
</blockquote>
<blockquote>
<p>假设训练集误差为1% 训练-开发集误差为1.5% 但是开发集误差为10% 这就是方差偏小的问题 因为从已经见过的训练集数据 到未见过的训练-开发集 误差只增加了一点点 但是到开发集出现了跃增 所以这是数据不匹配的问题</p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/bpLEM6XStfN5JIQ.png"></p>
</blockquote>
<h3 id="6-如何解决因为数据不匹配导致的误差"><a href="#6-如何解决因为数据不匹配导致的误差" class="headerlink" title="6. 如何解决因为数据不匹配导致的误差"></a>6. 如何解决因为数据不匹配导致的误差</h3><blockquote>
<p>如果发现出现了严重的数据不匹配问题 我通常会人工地分析误差 并且试着去理解训练集与开发/测试集之间的差异 为了避免测试集上的过拟合 技术上对误差分析来说 你的关注点应该只是开发集而不是测试集 </p>
</blockquote>
<blockquote>
<p>如果你的目标是使训练集与开发集更加相似 这样有什么解决方法呢？ 其中一个方法是你可以通过 人工数据合成 让我们在解决汽车噪声问题的背景下讨论这个问题。</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/09/mRLtkeq9loY4GDU.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/09/DL7%20-%20%E6%9E%84%E9%80%A0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%882%EF%BC%89/" data-id="ckgqfij2k000n7545bg5rdlrd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deeplearning/" rel="tag">deeplearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DL6 - 机器学习策略" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/07/DL6%20-%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5/" class="article-date">
  <time datetime="2019-09-07T05:56:01.000Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/deeplearning/">deeplearning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/07/DL6%20-%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5/">DL6 - 构造机器学习项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! This article was writed to take note my study of Machine Learning on <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning-projects/lecture/yeHYT/why-ml-strategy">Cousera</a>.</p>
<hr>
<h3 id="1-机器学习策略"><a href="#1-机器学习策略" class="headerlink" title="1 机器学习策略"></a>1 机器学习策略</h3><h4 id="1-1-什么是机器学习策略？"><a href="#1-1-什么是机器学习策略？" class="headerlink" title="1.1 什么是机器学习策略？"></a>1.1 什么是机器学习策略？</h4><blockquote>
<p>有快捷高效的方法 分辨出在之前提到的或者没有提到的各种想法中 哪些值得进行尝试 哪些可以直接放弃<br>一些基本套路 也就是一些分析机器学习问题的方法 这些方法 会让你避免南辕北辙 </p>
</blockquote>
<h4 id="1-2-正交化过程（调参，参数之间互不干扰）"><a href="#1-2-正交化过程（调参，参数之间互不干扰）" class="headerlink" title="1.2 正交化过程（调参，参数之间互不干扰）"></a>1.2 正交化过程（调参，参数之间互不干扰）</h4><blockquote>
<p>建立机器学习系统的挑战之一是*<strong>有太多可以尝试和改变的东西**<em>，例如调整的超参数。<br>最高效的机器学习人员都非常清楚需要调整什么，我们称这一过程为</em></strong>正交化***。</p>
</blockquote>
<p>实例：</p>
<pre><code>正交化就是指电视设计师 So in this context, orthogonalization refers to that 
the TV designers 在进行设计的时候 确保每个旋钮只能进行一个参数的调整 had designed 
the knobs so that each knob kind of does only one thing 
而这让电视屏幕的调整变得更加容易 And this makes it much easier to tune the TV, 
so 使得电视画面能够显示在你希望的位置上 that the picture gets centered where you 
want it to be.</code></pre>
<blockquote>
<p>为保证有监督脊椎的学习系统良好地运行，调整系统旋钮，保证四件事准确无误。</p>
</blockquote>
<blockquote>
<p>（1）通常确保至少训练组运行良好。因此训练组的运行情况需要进行一些可行性评估。<br>如果训练组表现良好, 你将希望这能使开发组运行良好，同时 你也会希望测试组运行良好， 最终 你希望能在成本函数的测试组里运行良好，因为结果会影响系统在实际情况中的表现， 因此 希望这能顺利地实现,</p>
</blockquote>
<blockquote>
<p>（2）相反，如果你发现算法对dev集的拟合结果不太好 那么 就需要另一套独立的旋钮 是的，这就是我画的不太好的，另一套旋钮 你需要有一套不同的旋钮 来调整(开发集的拟合结果) </p>
</blockquote>
<blockquote>
<p>（3）如果（算法）在dev集上表现很好 但是在测试集上不行呢？ 如果这样， 你可能想要一个调整的旋钮 用来获取一个更大的dev集 因为如果（算法）在dev集上表现很好 但测试集上不行，这可能意味着， 你过度调节了dev集 你需要返回去，寻找一个更大的dev集</p>
</blockquote>
<blockquote>
<p>（4）如果（算法）在测试集上表现也很好 但是依然不能给你 愉快的用户体验，这意味着你需要返回去 调整你的dev集或者成本函数</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/rJyVXgbN9FYfQLT.png"></p>
</blockquote>
</blockquote>
<h3 id="2-单数评价指标"><a href="#2-单数评价指标" class="headerlink" title="2. 单数评价指标"></a>2. 单数评价指标</h3><h4 id="2-1-F1-score"><a href="#2-1-F1-score" class="headerlink" title="2.1 F1 score"></a>2.1 F1 score</h4><pre><code>因此分类器A有95%的精准率 就意味着 A如果把一张图片分类为猫 那么95%可能它就是猫 
而召回率就是 对于所有是猫的图片 你的分类器有多少百分比可以正确的识别出来 
即多少比率的真猫被正确的识别出了</code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/jzKyAHMTe3nFR8W.png"></p>
</blockquote>
</blockquote>
<h4 id="2-2-满足指标（satisficing-matrics）和-优化指标（optimizing-matrics）"><a href="#2-2-满足指标（satisficing-matrics）和-优化指标（optimizing-matrics）" class="headerlink" title="2.2 满足指标（satisficing matrics）和 优化指标（optimizing matrics）"></a>2.2 满足指标（satisficing matrics）和 优化指标（optimizing matrics）</h4><blockquote>
<p>如果你同时关心多项指标， 你可以将其中的一样设为优化指标， 使其表现尽可能的好 ，将另外的一项或多项设为满足指标，确保其表现满足要求，大多数情况下他们都会优于最低标准，这样一来你就有了一个几乎自动的， 快速评价模型和选择”最佳”模型的方法</p>
</blockquote>
<blockquote>
<p>例子：<br>    你决定关注 猫分类器的分类准确率(accuracy) 它可以是F1分数(F1 score)<br>    或者别的什么精确度度量 但是假设 除了准确率之外你还关心运行时间<br>    也就是对一个图像分类需要多少时间<br />这个表中分类器A需要80毫秒(millisecond)<br>    B需要95毫秒 C需要1,500毫秒 也就是1.5秒才能甄别一个图像<br>    你当然可以将准确率和运行时间组合成一个 整体评价指标(overall evaluation metric)<br>    比如说整体代价是 准确率-0.5*运行时间 但是将准确率和运行时间用这样的公式整合<br>    看起来有些刻意 这就像二者的线性加权和(linear weighted sum) 所以你还可以这样做:<br>    你可能想要选择一个分类器 它在确保运行时间的前提下提供最大准确率<br>    比如说它甄别图像所花费的时间 必须&lt;=100毫秒 在这个例子中我们说准确率是优化指标<br>    因为你想要最大化准确率 你希望准确率尽可能的高 但是运行时间是我们我们所说的满足指标<br>    意味着它必须足够好 必须&lt;100毫秒 一旦超出即不予考虑 至少不大考虑<br>    所以用这种方式对准确率和运行时间</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/ayv7LAKw1z5WYpM.png"></p>
</blockquote>
</blockquote>
<h3 id="3-train-dev-test"><a href="#3-train-dev-test" class="headerlink" title="3. train/dev/test"></a>3. train/dev/test</h3><h4 id="3-1-开发集（dev）和测试集-应具有相同的分布"><a href="#3-1-开发集（dev）和测试集-应具有相同的分布" class="headerlink" title="3.1 开发集（dev）和测试集 应具有相同的分布"></a>3.1 开发集（dev）和测试集 应具有相同的分布</h4><blockquote>
<p> dev set 也被称为development set 或者有些时候被称为交叉验证集</p>
<p> 机器学习的工作流程是 你尝试了很多想法, 在训练集上训练不同的模型, 然后使用开发集来 评估不同的想法,并选择一个。 并且，保持创新， 提高模型在开发集上的表现性能 直到最后你有一个很高兴的结果 然后你在测试集上评估它们 </p>
<p>设置开发集 和检验方法 直接决定了你的目标 将开发和测试集取在同一分布上 你才真正瞄准了你和你团队的目标 你选择训练集的方法 会影响你击中目标的精度</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/yFo5exSmCgnrP7D.png"></p>
</blockquote>
</blockquote>
<h4 id="3-2-训练集、开发集、测试集的数据分布"><a href="#3-2-训练集、开发集、测试集的数据分布" class="headerlink" title="3.2 训练集、开发集、测试集的数据分布"></a>3.2 训练集、开发集、测试集的数据分布</h4><blockquote>
<p>该内容在之前的博客上已经记录过，在此不再赘述，<a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/2019/08/14/Improving%20Deep%20Neural%20Networks-%20Hyperparameter%20tuning,%20Regularization%20and%20Optimization/#more">blog</a></p>
</blockquote>
<h4 id="3-3-改变-开发集-测试集-和-评估标准"><a href="#3-3-改变-开发集-测试集-和-评估标准" class="headerlink" title="3.3 改变 开发集/测试集 和 评估标准"></a>3.3 改变 开发集/测试集 和 评估标准</h4><blockquote>
<p>我们已经学习了如何设置开发集和评估指标 这就好比确定你的团队要瞄准的靶子 可有时候 项目进行到一半 你可能会发现 靶子放错了位置 这时候 就应该移动你的靶子 </p>
</blockquote>
<blockquote>
<p>当你发现评估指标 无法对算法的优劣给出正确的排序时 那么就需要考虑定义一个新的评估指标 这里的例子只是定义评估指标的一种方法 评价指标的目的是为了能够准确地告诉你 给出两个分类器 哪一个更适合你的应用 就本次视频的目标而言 大家不需要太关心如何定义新的误差指标 重点是 如果你对原有的误差指标不满意 那就不要将就着使用这个你不满意的指标 而是定义一个新的指标 使其能够更好地 反应你的偏好 以符合你对更好的算法的定义 </p>
</blockquote>
<h4 id="3-4-定义评估指标十分重要"><a href="#3-4-定义评估指标十分重要" class="headerlink" title="3.4 定义评估指标十分重要"></a>3.4 定义评估指标十分重要</h4><blockquote>
<p><img src="https://i.loli.net/2019/09/07/2Fhenkzw5d3cMO8.png"></p>
</blockquote>
<h3 id="4-和人类级别绩效-比较"><a href="#4-和人类级别绩效-比较" class="headerlink" title="4. 和人类级别绩效 比较"></a>4. 和人类级别绩效 比较</h3><h4 id="4-1-为什么和人类级别绩效比较"><a href="#4-1-为什么和人类级别绩效比较" class="headerlink" title="4.1 为什么和人类级别绩效比较"></a>4.1 为什么和人类级别绩效比较</h4><blockquote>
<p>当你继续训练算法时 也许是越来越大模型和更多更大的数据 其效果逼近但从来不会超越一个理论值 这称为贝叶斯最优误差 所以贝叶斯最优误差就是最小的理论误差值</p>
</blockquote>
<p>举例：</p>
<pre><code>这就是用 从x到y的任何函数映射超过一定的准确度 
例如对于语音识别，如果x是音频，一些音频就是 太多吵噪而无法判断它在讲什么 
所以理论准确度可能不是 100% 或是猫识别 一些图像很模糊，它是不可能让 
任何人或其他什么事物认出那幅画里有一只猫 所以，精度的完美水平可能不是100％ 
贝叶斯最优误差，贝叶斯最佳误差或贝叶斯错误 简而言之，是从x到y映射的最好的理论函数</code></pre>
<blockquote>
<p>事实证明，进度往往相当快 直到你超越人类的表现</p>
<p>你若超越了人类的表现，有时反而慢下来 我认为有两个主要原因 为什么当你超越人类级别的表现时进展往往放慢 原因之一，人类级别的表现 在许多任务中都离贝叶斯最优误差不远 人非常擅长看着图像去分辨是否有一只猫 或收听音频并写出字幕。 因此，可能算法超越人类级别的表现之后并没有，那么大的改善空间</p>
<p>第二个原因，只要你的表现还不如人类水平 那么实际上你可以用某些工具来提高 而当你超越了人类的水平后，就很难再有工具来提高了 就是这样子</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/QHnvqzS6V4bIUc2.png"></p>
</blockquote>
<p>只要你的机器学习算法 比人类更糟糕，你就可以从人类得到数据标记 这是你可以问人，问聪明的人，为你的例子标签 这样你可以有更多的数据以满足你的学习算法 我们下周会讲的是手动误差分析 只要人类仍表现优于任何算法，你可以 让人看看你的算法算错的例子，然后了解 为什么人可以做到，但该算法却搞错了。你也可以得到更好的偏见分析和 方差，一旦你的算法做的比人类优异 这三招将变的很难应用</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/aPuJo3bSykEdXYM.png"></p>
</blockquote>
</blockquote>
<h4 id="4-2-可避免误差（avoidable-bias）"><a href="#4-2-可避免误差（avoidable-bias）" class="headerlink" title="4.2 可避免误差（avoidable bias）"></a>4.2 可避免误差（avoidable bias）</h4><blockquote>
<p>贝叶斯误差和训练集上的误差 之间的 距离，称为可避免的偏差。</p>
<p>模型在训练集与开发集上的误差之差 则是对模型中存在的方差问题的度量</p>
</blockquote>
<h4 id="4-3-理解人类级别表现（human-level-performance）"><a href="#4-3-理解人类级别表现（human-level-performance）" class="headerlink" title="4.3 理解人类级别表现（human-level performance）"></a>4.3 理解人类级别表现（human-level performance）</h4><pre><code>把人类误差当做贝叶斯误差的替代值或估计值
有一个好的贝叶斯误差估计 可以很好的帮助你评估可避免的偏差和方差 
从而更利于做决定究竟是专注于偏差降低技术 还是方差降低技术
这个方法在你超越人类水平表现之前是一直有效果的</code></pre>
<blockquote>
<p>不管你使用普通医生的还是 一个专业医生的或者是一个有经验的医生团队的 因为这里是4%或4.5% 这明显要大于方差误差（1%） 你必须要确保终止循环的条件一定会达成 你需要专注与降低偏差的技术比如训练更大网络 在让我们看第二个例子 比如你的训练误差是1%而你的验证误差是5% 出学术目的外 无论你选择1% 0.7%或是0.5%哪个 作为人类水平的表现都没有什么区别 因为不管你用哪个定义 你可避免误差的度量 我猜差不多是0%到0.5% 对不对？ 这是人类水平的表现和你训练误差的差距 而这里的差距是4% 因此4%在这里要远大于可以避免的偏差 所以你需要专注于方差降低的技术 比如正则化或者使用一个更大的训练集 但是真正有问题的时候是如果你的训练集误差为0.7% 当然这已经非常好了 而你的开发集误差为0.8% 在这种情况下把你的贝叶斯误差估计定为0.5%就很有必要了</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/XbP1xM6WyNYCchJ.png"></p>
</blockquote>
</blockquote>
<h4 id="4-4-总结：如何提高你的模型表现"><a href="#4-4-总结：如何提高你的模型表现" class="headerlink" title="4.4 总结：如何提高你的模型表现"></a>4.4 总结：如何提高你的模型表现</h4><blockquote>
<p>一般，认为一个有监督学习算法能发挥作用，基本上意味着，希望或者预设你可以做到两件事 第一是你可以很好地拟合训练集，你可以大致认为你能得到较低的可避免偏差。</p>
<p>第二点是 训练集的结果可以很好地，推广到开发集或者测试集 这就是说 方差不太大 从正交化角度来说 你看到的是 存在一组旋钮<br />可以修正可避免偏差的问题 比如训练更大的神经网络<br />或者训练更长时间 并且有另一组独立的方法<br />可以用来处理方差的问题 比如正则化或者获取更多训练数据</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/07/PfGpd8wunLmBQCx.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/07/DL6%20-%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5/" data-id="ckgqfij2j000k75455ehf89wz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deeplearning/" rel="tag">deeplearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ml3 - classification" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/ml3%20-%20classification/" class="article-date">
  <time datetime="2019-09-06T11:46:15.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine-Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/ml3%20-%20classification/">ML3 - 分类问题（逻辑回归）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! This article was writed to take note my study of Machine Learning on <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning/lecture/wlPeP/classification">Cousera</a>.</p>
<hr>
<h3 id="1-用线性回归训练二分类器"><a href="#1-用线性回归训练二分类器" class="headerlink" title="1. 用线性回归训练二分类器"></a>1. 用线性回归训练二分类器</h3><p>原文：分类问题其实和回归问题类似</p>
<pre><code>To attempt classification, one method is to use linear regression and map
all predictions greater than 0.5 as a 1 and all less than 0.5 as a 0.
However, this method doesn&#39;t work well because classification is not 
actually a linear function

The classification problem is just like the regression problem.</code></pre>
<h3 id="2-逻辑回归-（sigmoid函数、逻辑函数、S函数-基本是同义词）"><a href="#2-逻辑回归-（sigmoid函数、逻辑函数、S函数-基本是同义词）" class="headerlink" title="2. 逻辑回归 （sigmoid函数、逻辑函数、S函数 基本是同义词）"></a>2. 逻辑回归 （sigmoid函数、逻辑函数、S函数 基本是同义词）</h3><h4 id="2-1-函数表示-假设函数"><a href="#2-1-函数表示-假设函数" class="headerlink" title="2.1 函数表示(假设函数)"></a>2.1 函数表示(假设函数)</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/5vSF2KY7DXonsg9.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/7Mv8yNRaklhojfO.png"></p>
</blockquote>
</blockquote>
<h4 id="2-2-决策边界（decision-boundary"><a href="#2-2-决策边界（decision-boundary" class="headerlink" title="2.2 决策边界（decision boundary)"></a>2.2 决策边界（decision boundary)</h4><blockquote>
<p>决策边界是 假设函数的一个属性 它包括参数θ0 θ1 θ2 在这幅图中 我画了一个训练集 我画了一组数据 让它更加可视化 但是 即使我们 去掉这个数据集 这条决策边界 和我们预测y等于1 与y等于0的区域 它们都是 假设函数的属性 决定于其参数 它不是数据集的属性</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/kR92S4UxNq7VXBZ.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>非线性决策边界,甚至是更复杂的边界（只要参数够多，比如多项、多元参数），举例如下：</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/XsaZJKzbmxFYk5l.png"></p>
</blockquote>
</blockquote>
<h4 id="2-3-损失函数-cost-function"><a href="#2-3-损失函数-cost-function" class="headerlink" title="2.3 损失函数 cost function"></a>2.3 损失函数 cost function</h4><blockquote>
<p>我们不能使用与线性回归相同的成本函数，因为logistic函数会导致输出波动，导致许多局部最优。换句话说，它不是凸函数。<br>以下面方式编写成本函数可以保证逻辑回归的j（θ）是**<em>凸**</em>的：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/T3t1oapQrzOvYW6.png"></p>
</blockquote>
</blockquote>
<pre><code>如果我们的正确答案“y”是1，那么如果我们的假设函数输出1，那么成本函数将是0。
如果我们的假设接近于0，那么成本函数将接近无穷大。</code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/irs24LbGnMx1oAE.png"></p>
</blockquote>
</blockquote>
<pre><code>如果我们的正确答案“y”为0，那么如果我们的假设函数也输出0，那么成本函数将为0。
如果我们的假设接近1，那么成本函数将接近无穷大。</code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/EJ4rj3vIhRLlKHW.png"></p>
</blockquote>
</blockquote>
<h4 id="2-4-损失函数简化版"><a href="#2-4-损失函数简化版" class="headerlink" title="2.4 损失函数简化版"></a>2.4 损失函数简化版</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/SipTFlJaAZbm5CH.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/lvFehGA9cVnaLmE.png"></p>
</blockquote>
</blockquote>
<h4 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h4><blockquote>
<p>梯度下降的计算，线性回归和逻辑回归的区别只在于h(theta)</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/06/Eq8jYifJmrFaUSw.png"></p>
</blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/06/ml3%20-%20classification/" data-id="ckgqfij2s001775450yk6dgfq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cousera/" rel="tag">cousera</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ml2-model &amp; cost_function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/31/ml2-model%20&%20cost_function/" class="article-date">
  <time datetime="2019-08-31T02:25:58.000Z" itemprop="datePublished">2019-08-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine-Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/31/ml2-model%20&%20cost_function/">ML2 - 线性回归模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://five-second-curry-stick.github.io/">MyBlog</a>! This article was writed to take note my study of Machine Learning on <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning/supplement/1O0Bk/unsupervised-learning">Cousera</a>.</p>
<hr>
<h3 id="1-单元-线性回归模型-linear-regression"><a href="#1-单元-线性回归模型-linear-regression" class="headerlink" title="1. 单元 线性回归模型 linear regression"></a>1. 单元 线性回归模型 linear regression</h3><blockquote>
<p>h表示映射关系</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/08/31/8p2wRfWUzrc1Vuk.png"></p>
</blockquote>
</blockquote>
<h4 id="1-1-代价函数"><a href="#1-1-代价函数" class="headerlink" title="1.1 代价函数"></a>1.1 代价函数</h4><blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/03/2rXLciOMK6DtICp.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是建模误差（modeling error）</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/03/aRMZ5Ykhg9WDCeU.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>为了选出使得modeling error的平方和最小的模型参数。即代价函数：</p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/BGDMc4FgH1dmLQO.png"></p>
</blockquote>
</blockquote>
<h4 id="1-2-梯度下降"><a href="#1-2-梯度下降" class="headerlink" title="1.2 梯度下降"></a>1.2 梯度下降</h4><blockquote>
<p>一种有效的算法，能够自动找出使代价函数J取最小值的参数θ0和θ1.</p>
</blockquote>
<h3 id="2-多元线性回归"><a href="#2-多元线性回归" class="headerlink" title="2. 多元线性回归"></a>2. 多元线性回归</h3><h4 id="2-1-多元线性回归的向量形式"><a href="#2-1-多元线性回归的向量形式" class="headerlink" title="2.1 多元线性回归的向量形式"></a>2.1 多元线性回归的向量形式</h4><blockquote>
<p>转换成向量形式，如下：</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/oLtJ1crEYwgR3IM.png"></p>
</blockquote>
</blockquote>
<h4 id="2-2-用梯度下降解决多特征的线性回归问题"><a href="#2-2-用梯度下降解决多特征的线性回归问题" class="headerlink" title="2.2 用梯度下降解决多特征的线性回归问题"></a>2.2 用梯度下降解决多特征的线性回归问题</h4><blockquote>
<p><img src="https://i.loli.net/2019/09/04/dYTN1lHDRUAWMQE.png"></p>
</blockquote>
<h3 id="3-特征缩放"><a href="#3-特征缩放" class="headerlink" title="3. 特征缩放"></a>3. 特征缩放</h3><h4 id="3-1-缩放目的"><a href="#3-1-缩放目的" class="headerlink" title="3.1 缩放目的"></a>3.1 缩放目的</h4><blockquote>
<p>这个问题有多个特征 如果你能确保这些特征 都处在一个相近的范围 我的意思是确保 不同特征的取值 在相近的范围内<br>下面举一个反面例子：</p>
<blockquote>
<p>假如你有一个具有两个特征的问题 其中 x1 是房屋面积大小 它的取值 在0到2000之间 x2 是卧室的数量 可能这个值 取值范围在1到5之间 如果你画出代价函数 J(θ) 的轮廓图<br><img src="https://i.loli.net/2019/09/04/7AkbFeJryxTBYvO.png"></p>
</blockquote>
</blockquote>
<h4 id="3-2-缩放（特征缩放其实并不需要太过准确，只是为了加速梯度下降）"><a href="#3-2-缩放（特征缩放其实并不需要太过准确，只是为了加速梯度下降）" class="headerlink" title="3.2 缩放（特征缩放其实并不需要太过准确，只是为了加速梯度下降）"></a>3.2 缩放（特征缩放其实并不需要太过准确，只是为了加速梯度下降）</h4><pre><code>1. 不用过于担心 你的特征是否在完全 相同的范围或区间内 
但是只要他们都 只要它们足够接近的话 梯度下降法就会正常地工作</code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/e5GDC3ZjN29EvST.png"></p>
</blockquote>
</blockquote>
<pre><code>2. 均值规范化处理
其中，S为标准差（实际上，用最大值-最小值也是可以的），miu为均值</code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/SIHqo2VXGbfxOwJ.png"></p>
</blockquote>
</blockquote>
<h3 id="4-学习率alpha的选择"><a href="#4-学习率alpha的选择" class="headerlink" title="4. 学习率alpha的选择"></a>4. 学习率alpha的选择</h3><blockquote>
<p>通过损失函数的图像判断</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/1CrGXmAplnWcF5D.png"><br><img src="https://i.loli.net/2019/09/04/IbYnPl5LfCQEv7o.png"></p>
</blockquote>
</blockquote>
<h3 id="5-特征-和-多项式回归（polynomial-regression）【和多元相对应】"><a href="#5-特征-和-多项式回归（polynomial-regression）【和多元相对应】" class="headerlink" title="5. 特征 和 多项式回归（polynomial regression）【和多元相对应】"></a>5. 特征 和 多项式回归（polynomial regression）【和多元相对应】</h3><h4 id="5-1-选择特征的方法"><a href="#5-1-选择特征的方法" class="headerlink" title="5.1 选择特征的方法"></a>5.1 选择特征的方法</h4><blockquote>
<p>有时 通过定义 新的特征 你确实会得到一个更好的模型 与选择特征的想法 </p>
</blockquote>
<pre><code>We can combine multiple features into one. For example, we can combine x1 and x2 into a new feature x3 by taking x1⋅x2.

以预测房价为例 假设你有两个特征 分别是房子临街的宽度和垂直宽度 这就是我们想要卖出的房子的图片 临街宽度 被定义为这个距离 其实就是它的宽度 或者说是 你拥有的土地的宽度 如果这块地都是你的的话 而这所房子的 纵向深度就是 你的房子的深度 这是正面的宽度 这是深度 我们称之为临街宽度和纵深 你可能会 像这样 建立一个 线性回归模型 其中临街宽度 是你的第一个特征x1 纵深是你的第二个 特征x2 但当我们在 运用线性回归时 你不一定非要直接用 给出的 x1 和 x2 作为特征 其实你可以自己创造新的特征 因此 如果我要预测 房子的价格 我真正要需做的 也许是 确定真正能够决定 我房子大小 或者说我土地大小 的因素是什么 因此 我可能会创造一个新的特征 我称之为 x 它是临街宽度与纵深的乘积 </code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/UBqtG6pwixNRo3V.png"></p>
</blockquote>
</blockquote>
<h4 id="5-2-如何得到不同的学习算法"><a href="#5-2-如何得到不同的学习算法" class="headerlink" title="5.2 如何得到不同的学习算法"></a>5.2 如何得到不同的学习算法</h4><blockquote>
<p>如何将一个 多项式 如一个二次函数 或一个三次函数拟合到你的数据</p>
</blockquote>
<pre><code>Our hypothesis function need not be linear (a straight line) if that does not fit the data well.
We can change the behavior or curve of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).</code></pre>
<blockquote>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/k75MyQtjdXgsxlC.png"></p>
</blockquote>
</blockquote>
<h3 id="6-正规方程"><a href="#6-正规方程" class="headerlink" title="6. 正规方程"></a>6. 正规方程</h3><blockquote>
<p>对于某些线性回归问题 它给出了一个更好的方法 求出参数 θ 的最优解<br>相对于梯度下降一步步求到最优解，正规方程法，提供了一种求theta的解析接发，可以一次性求解theta的最优解</p>
</blockquote>
<h4 id="6-1-正规方程直观理解"><a href="#6-1-正规方程直观理解" class="headerlink" title="6.1 正规方程直观理解"></a>6.1 正规方程直观理解</h4><blockquote>
<p><img src="https://i.loli.net/2019/09/04/q4IEYdNQCme3aZ9.png"><br><img src="https://i.loli.net/2019/09/04/jnqKFwdAbZQaeki.png"></p>
</blockquote>
<h4 id="6-2-如何选择梯度下降-和-正规方程法-只适用于线性回归"><a href="#6-2-如何选择梯度下降-和-正规方程法-只适用于线性回归" class="headerlink" title="6.2 如何选择梯度下降 和 正规方程法(只适用于线性回归)"></a>6.2 如何选择梯度下降 和 正规方程法(只适用于线性回归)</h4><blockquote>
<p>只要特征变量的数目并不大 正规方程是一个很好的 计算参数 θ 的替代方法 具体地说 只要特征变量数量小于一万 具体地说 只要特征变量数量小于一万 我通常使用正规方程法 我通常使用正规方程法 而不使用梯度下降法</p>
<blockquote>
<p><img src="https://i.loli.net/2019/09/04/w5sBSWVDGgda74r.png"></p>
</blockquote>
</blockquote>
<h4 id="6-3-正规方程的不可逆性"><a href="#6-3-正规方程的不可逆性" class="headerlink" title="6.3 正规方程的不可逆性"></a>6.3 正规方程的不可逆性</h4><pre><code>当你发现的矩阵X&#39;X的结果是奇异矩阵 或者找到的其它矩阵是不可逆的 我会建议你这么做 首先 看特征值里是否有一些多余的特征</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/08/31/ml2-model%20&%20cost_function/" data-id="ckgqfij2r001475459utxh5i5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cousera/" rel="tag">cousera</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine-Learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/deeplearning/">deeplearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%80%BC%E4%BC%98%E5%8C%96/">数值优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/">数学之美</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%8C%AE%E7%90%86%E8%A7%A3/">文献理解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cousera/" rel="tag">cousera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deeplearning/" rel="tag">deeplearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%80%BC%E4%BC%98%E5%8C%96/" rel="tag">数值优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/" rel="tag">数学之美</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%8C%AE%E7%90%86%E8%A7%A3/" rel="tag">文献理解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/cousera/" style="font-size: 15px;">cousera</a> <a href="/tags/deeplearning/" style="font-size: 20px;">deeplearning</a> <a href="/tags/python/" style="font-size: 12.5px;">python</a> <a href="/tags/%E6%95%B0%E5%80%BC%E4%BC%98%E5%8C%96/" style="font-size: 12.5px;">数值优化</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/" style="font-size: 17.5px;">数学之美</a> <a href="/tags/%E6%96%87%E7%8C%AE%E7%90%86%E8%A7%A3/" style="font-size: 10px;">文献理解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/09/%E6%95%B0%E5%80%BC%E4%BC%98%E5%8C%964%20-%20%E7%BA%BF%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95%E7%9A%84%E6%94%B6%E6%95%9B%E6%80%A7%E5%92%8C%E6%94%B6%E6%95%9B%E9%80%9F%E5%BA%A6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/10/05/%E4%B8%8D%E5%AE%8C%E6%95%B4/%E6%96%87%E7%8C%AE%E7%90%86%E8%A7%A31%20-%20LCF/">文献理解 - LCF</a>
          </li>
        
          <li>
            <a href="/2019/09/26/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E16%20-%20%E4%BF%A1%E6%81%AF%E6%8C%87%E7%BA%B9/">数学之美16 - 信息指纹及其应用</a>
          </li>
        
          <li>
            <a href="/2019/09/25/DL12%20-%20CNN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">DL12 - CNN基础知识</a>
          </li>
        
          <li>
            <a href="/2019/09/22/%E6%95%B0%E5%80%BC%E4%BC%98%E5%8C%963%20-%20%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95/">数值优化3 - 线搜索方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Jianhao Yang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>